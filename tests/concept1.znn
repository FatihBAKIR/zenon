// 3

template <T, U, V>
concept CanAdd {
  V add(T* t, U u);
};

template <T>
concept CanCopy {
  T(T*);
};

struct S {
};

int add(S* s, bool a) {
  if (a)
    return 1;
  else
    return 2;
}

template <A, B, C> requires CanAdd<A, B, C>, CanCopy<B>
C add2(A a, B b) {
  return a.add(b);
}

template <A1, B1, C1> requires CanAdd<A1, B1, C1>
struct S2 {
};

template <A, B, C> requires CanAdd<A, B, C>, CanCopy<B>
C add3(S2<A, B, C> s, A a, B b) {
  return a.add(b);
}

void fun(S2<S, bool, int> s) {
}

int main() {
  const s = S();
  S2<S, bool, int> s2 = S2<S, bool, int>();
  return add2<S, bool, int>(s, false) + s2.add3(s, true);
}
